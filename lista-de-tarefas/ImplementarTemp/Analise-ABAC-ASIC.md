# üö® OBRIGAT√ìRIO: CORRE√á√ÉO DE ERROS A CADA PASSO üö®

**A cada etapa implementada (refatora√ß√£o, migra√ß√£o, limpeza, ajuste de permiss√£o, etc), √© OBRIGAT√ìRIO executar e corrigir:**
- **Primeiro:** TODOS os erros e avisos de LINT (eslint, prettier, etc)
- **Depois:** TODOS os erros de TYPESCRIPT (type-check)
- **Depois:** TODOS os erros de COMPILA√á√ÉO (build)

**NUNCA avance para a pr√≥xima etapa sem garantir que o projeto est√° 100% limpo de erros nestas tr√™s categorias.**

---
## IMPLEMENTA√á√ÉO DA CENTRALIZA√á√ÉO DE PERMISS√ïES ABAC E LIMPEZA ESTRUTURAL (PROCEDIMENTO OBRIGAT√ìRIO)

### Centraliza√ß√£o das Permiss√µes ABAC

- **Toda l√≥gica de permiss√£o deve ser centralizada no backend, usando Casbin (enforcer) e policies persistidas em CasbinRule.**
- O backend deve expor as permiss√µes do usu√°rio autenticado via endpoint seguro (ex: `/api/auth/permissions`), retornando as a√ß√µes permitidas para cada recurso.
- O frontend deve consumir essas permiss√µes e condicionar a UI, mas nunca implementar l√≥gica de permiss√£o real.
- **Nunca duplique regras de permiss√£o no frontend.**
- Toda checagem de permiss√£o em endpoints, middlewares, loaders, mutations, etc, deve ser feita via enforcer Casbin, usando os atributos do usu√°rio e do recurso.
- **Exemplo de fluxo:**
  1. Usu√°rio faz login ‚Üí backend carrega policies do CasbinRule.
  2. Backend exp√µe as permiss√µes do usu√°rio via endpoint seguro.
  3. Frontend consome e usa para condicionar UI.
  4. Toda requisi√ß√£o sens√≠vel √© validada novamente no backend via enforcer.
- **Pol√≠ticas devem ser versionadas, auditadas e documentadas.**
- **Nunca use enums, strings fixas ou campos herdados do RBAC para permiss√£o.**

---

## LIMPEZA ESTRUTURAL OBRIGAT√ìRIA AP√ìS MIGRA√á√ÉO

### 1. Remover arquivos antigos, backups e nomes fora do padr√£o
- **Ap√≥s a migra√ß√£o e revis√£o completa, √© OBRIGAT√ìRIO buscar e remover todos os arquivos e pastas com nomes contendo:**
  - `old`, `bak`, `backup`, `antigo`, `deprecated`, `legacy`, etc.
- **Deve restar apenas UM arquivo de an√°lise final e atualizado.**
- **Arquivos de log, scripts, seeds, policies, configs, etc, devem ser mantidos apenas na vers√£o final e padronizada.**

### 2. Padroniza√ß√£o de nomes de arquivos
- **Buscar e renomear/remover todos os arquivos e pastas com sufixos ou prefixos como `moderno`, `simples`, `novo`, `new`, etc.**
- **O padr√£o deve ser sempre o nome funcional do recurso, sem adjetivos ou complementos.**
- **Exemplo:**
  - `log-moderno.ts` ‚Üí `log.ts`
  - `sistema-simples.ts` ‚Üí `sistema.ts`
- **Revisar todos os imports e refer√™ncias ap√≥s renomea√ß√£o para n√£o quebrar nada.**

### 3. Remover arquivos e pastas sem uso, em branco ou marcados para deletar
- **Buscar e deletar todos os arquivos e pastas sem uso, em branco, ou marcados para exclus√£o.**
- **Confirmar a exclus√£o e garantir que n√£o retornem ao reposit√≥rio.**
- **Esse procedimento deve ser feito em TODA a pasta `site-metodo/` e destacado como fundamental para a sa√∫de do projeto.**

---

## CHECKLIST DE TESTES MANUAIS DE ENDPOINTS E FLUXOS DE USU√ÅRIO (OBRIGAT√ìRIO)

### üö® **TESTE MANUAL DE TODOS OS ENDPOINTS E LINKS NO NAVEGADOR DO VS CODE** üö®

**Procedimento obrigat√≥rio ap√≥s cada refatora√ß√£o/migra√ß√£o:**

1. **Acessar TODOS os links e endpoints relevantes do sistema no navegador do VS Code, para os dois perfis:**
   - Usu√°rio admin: `felipemartinii@gmail.com`
   - Usu√°rio comum (n√£o admin)

2. **Testar e registrar:**
   - Se o admin acessa todas as √°reas: `/area-cliente`, `/admin/dashboard`, `/admin/abac`, etc.
   - Se o usu√°rio comum acessa apenas o permitido e recebe mensagem adequada ao tentar acessar √°reas restritas.
   - Se h√° erros, mensagens inadequadas ou comportamentos inesperados.
   - Repetir o teste mais de uma vez para garantir consist√™ncia.

3. **Corrigir imediatamente qualquer erro encontrado.**

4. **Destacar e documentar este procedimento na an√°lise final.**

> **Este checklist √© OBRIGAT√ìRIO e deve ser seguido rigorosamente ap√≥s cada altera√ß√£o estrutural.**

---

## RESUMO FINAL E PR√ìXIMOS PASSOS

- Centralizar todas as permiss√µes no backend usando Casbin/ABAC puro.
- Expor permiss√µes para o frontend apenas para UX.
- Realizar limpeza completa de arquivos antigos, nomes fora do padr√£o e arquivos sem uso.
- Testar manualmente todos os fluxos e endpoints para todos os perfis.
- Documentar e auditar todo o processo.

---
## Revis√£o: Verifica√ß√£o de Permiss√£o ABAC em Endpoints e Componentes Frontend

### 1. Princ√≠pios Gerais

- **A verifica√ß√£o de permiss√£o deve SEMPRE ser feita no backend**. O frontend nunca pode ser considerado seguro, pois pode ser manipulado pelo usu√°rio. Toda l√≥gica de autoriza√ß√£o real deve ser centralizada e aplicada no backend (API, endpoints, middlewares, ORM, etc).

- **No frontend, a verifica√ß√£o de permiss√£o serve apenas para experi√™ncia do usu√°rio (UX)**: esconder bot√µes, menus, rotas, campos, etc. Isso evita frustra√ß√£o e torna a interface mais intuitiva, mas n√£o garante seguran√ßa.

- **A l√≥gica de permiss√£o deve ser centralizada e reutiliz√°vel**. O ideal √© que o backend exponha as permiss√µes do usu√°rio (ou as decis√µes de pol√≠tica) para o frontend, evitando duplica√ß√£o de regras e inconsist√™ncias.

### 2. Recomenda√ß√µes de fontes oficiais e melhores pr√°ticas

- **freeCodeCamp (2025):**
  - Pol√≠ticas ABAC devem ser aplicadas tanto no backend (para seguran√ßa) quanto no frontend (para UX).
  - O backend deve ser a fonte da verdade das pol√≠ticas e decis√µes de permiss√£o.
  - O frontend pode consumir as permiss√µes do backend e us√°-las para condicionar a renderiza√ß√£o de componentes, rotas e a√ß√µes.
  - Exemplo: O backend exp√µe um endpoint `/user/access_policies` ou retorna as permiss√µes junto com o usu√°rio autenticado.
  - O frontend utiliza essas permiss√µes para mostrar/ocultar bot√µes, menus, rotas, etc.
  - **Nunca confie apenas no frontend para proteger dados ou a√ß√µes sens√≠veis.**

- **DEV.to, OWASP, StackOverflow:**
  - O frontend pode e deve usar permiss√µes para melhorar a UX, mas toda checagem cr√≠tica deve ser repetida no backend.
  - Centralize a l√≥gica de permiss√£o para evitar bugs e inconsist√™ncias.
  - Use frameworks/bibliotecas que permitam compartilhar a l√≥gica de permiss√£o entre backend e frontend (ex: Casbin, CASL, OPA, Policy as Code, etc).

- **Permit.io, Frontegg, Medium:**
  - ABAC √© mais flex√≠vel e escal√°vel que RBAC, mas exige centraliza√ß√£o e versionamento das pol√≠ticas.
  - Use "Policy as Code" e sincronize as decis√µes de permiss√£o entre backend e frontend.
  - O frontend pode consumir as decis√µes do backend via API, cache ou contexto global.

### 3. Exemplos pr√°ticos

- O backend exp√µe as permiss√µes do usu√°rio autenticado:
  ```json
  {
    "post": { "create": true, "edit": false, "delete": false },
    "user": { "edit": true }
  }
  ```
  O frontend consome esse objeto e usa para condicionar a renderiza√ß√£o:
  ```tsx
  {permissoes.post.create && <Button>Criar Post</Button>}
  ```

- Para granularidade, o backend pode expor permiss√µes por recurso:
  ```json
  {
    "post:123": { "edit": true, "delete": false },
    "post:456": { "edit": false, "delete": false }
  }
  ```

- O frontend pode usar hooks ou componentes como `<Can />` para condicionar UI:
  ```tsx
  <Can I="edit" a={post}>
    <Button>Editar</Button>
  </Can>
  ```

### 4. Resumo das melhores pr√°ticas

- **Backend:**
  - Centralize e versiona as pol√≠ticas ABAC.
  - Exponha as permiss√µes do usu√°rio para o frontend de forma segura e eficiente.
  - Sempre aplique as checagens de permiss√£o em todos os endpoints e opera√ß√µes sens√≠veis.

- **Frontend:**
  - Use as permiss√µes fornecidas pelo backend para condicionar a UI.
  - Nunca confie apenas no frontend para proteger dados ou a√ß√µes.
  - Use hooks, contextos ou componentes reutiliz√°veis para checagem de permiss√£o.

- **Geral:**
  - Evite duplica√ß√£o de l√≥gica de permiss√£o.
  - Prefira "Policy as Code" e sincroniza√ß√£o de decis√µes.
  - Documente e audite as pol√≠ticas e pontos de checagem.


### 5. Refer√™ncias (TODOS DEVEM SER ACESSADOS E ANALISADOS ANTES DE QUALQUER IMPLEMENTA√á√ÉO)

- [freeCodeCamp: How to Build Scalable Access Control for Your Web App (2025)](https://www.freecodecamp.org/news/how-to-build-scalable-access-control-for-your-web-app/) ‚Äî Guia completo e atualizado sobre ABAC, frontend/backend, exemplos pr√°ticos e melhores pr√°ticas.
- [DEV.to: Permissions (access control) in web apps](https://dev.to/wasp/permissions-access-control-in-web-apps-j6b) ‚Äî Conceitos, recomenda√ß√µes OWASP, centraliza√ß√£o e frameworks.
- [Frontegg: ABAC Guide](https://frontegg.com/guides/abac) ‚Äî Guia pr√°tico, desafios, benef√≠cios e exemplos de uso real.
- [Permit.io: How to Implement ABAC](https://www.permit.io/blog/how-to-implement-abac) ‚Äî Implementa√ß√£o, Policy as Code, integra√ß√£o com OPA, exemplos de c√≥digo.
- [Medium: ABAC in React](https://medium.com/@dev_aman/attribute-based-access-control-abac-in-react-a-scalable-approach-df4990c7cbf0) ‚Äî Exemplo pr√°tico de ABAC no frontend React.
- [OWASP Authorization Cheat Sheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authorization_Cheat_Sheet.md) ‚Äî Checklist de seguran√ßa, centraliza√ß√£o e melhores pr√°ticas.
- [Casbin ABAC Model Example](https://github.com/casbin/casbin/blob/master/examples/abac_model.conf) ‚Äî Exemplo oficial de modelo ABAC Casbin.
- [Casbin GitHub](https://github.com/casbin/casbin) ‚Äî Reposit√≥rio oficial, releases, issues e exemplos.
- [Prisma Adapter Casbin](https://github.com/node-casbin/prisma-adapter) ‚Äî Integra√ß√£o Casbin + Prisma.
- [ABAC vs RBAC Auth0](https://auth0.com/docs/secure/access-control/rbac/) ‚Äî Comparativo pr√°tico e recomenda√ß√µes de migra√ß√£o.
- [ASIC Model Overview](https://github.com/casbin/casbin/blob/master/docs/model.md) ‚Äî Documenta√ß√£o oficial do modelo ASIC.
- [Casbin Online Editor](https://casbin.org/editor/) ‚Äî Ferramenta para testar e validar policies Casbin.

**Todos os links acima DEVEM ser acessados, lidos e analisados antes de qualquer implementa√ß√£o, refatora√ß√£o ou decis√£o.**

---
## üö® ETAPA FINAL OBRIGAT√ìRIA: EXECUTAR TODAS AS TAREFAS DE `lista-de-tarefas/ImplementarTemp` üö®

Assim que toda a revis√£o, migra√ß√£o e implementa√ß√£o do ABAC/ASIC estiver conclu√≠da e validada (com todos os erros de lint, typescript e compila√ß√£o zerados), √© OBRIGAT√ìRIO:

1. **Acessar, ler e entender a fundo TODAS as tarefas presentes na pasta `lista-de-tarefas/ImplementarTemp`.**
2. **Implementar cada tarefa de forma completa, autom√°tica e sequencial, sem pular nenhuma.**
3. **Documentar cada etapa e garantir que todas as tarefas sejam conclu√≠das antes de encerrar o ciclo.**

> **Esta etapa √© obrigat√≥ria para garantir a evolu√ß√£o cont√≠nua e a qualidade do projeto.**

---

---

**Resumo:**

- O frontend deve usar permiss√µes para UX, mas nunca para seguran√ßa real.
- O backend √© sempre a fonte da verdade e respons√°vel por toda checagem cr√≠tica.
- Centralize, documente e sincronize as pol√≠ticas ABAC entre backend e frontend.
# An√°lise Profunda ABAC/ASIC ‚Äì SiteMetodoAtuarial

## Sum√°rio
- **Data:** 12/08/2025
- **Respons√°vel:** GitHub Copilot
- **Objetivo:** An√°lise exaustiva da implementa√ß√£o ABAC/ASIC, identifica√ß√£o de resqu√≠cios de RBAC/accessLevel, compara√ß√£o com padr√µes oficiais ASIC, an√°lise de seeds e inconsist√™ncias, documenta√ß√£o de problemas e refer√™ncias.

---

## 1. Contexto do Projeto
- **Stack:** Next.js, TypeScript, Prisma, Casbin (ABAC/ASIC), NextAuth.js
- **Objetivo:** Controle de acesso baseado em atributos (ABAC/ASIC puro), eliminando RBAC/accessLevel.
- **Problemas reportados:**
  - Admin (felipemartinii@gmail.com) n√£o acessa /admin/abac
  - Novos usu√°rios n√£o acessam √°rea do cliente
  - Poss√≠vel loop de redirecionamento para usu√°rios n√£o autorizados
  - Resqu√≠cios de RBAC/accessLevel ainda presentes
  - Seeds inconsistentes (usu√°rio errado felipemartiniii@gmail.com)

---

## 2. Diagn√≥stico Inicial
- **Arquivos-chave lidos:**
  - src/app/admin/abac/page.tsx
  - src/lib/abac/hoc.tsx
  - src/lib/abac/client.ts
  - src/app/api/abac/check/route.ts
  - src/lib/abac/enforcer.ts
  - src/lib/abac/prisma-adapter.ts
  - src/app/api/abac/roles/route.ts
  - src/app/api/abac/policies/route.ts
  - src/types/next-auth.d.ts
  - src/lib/auth/apiAuth.ts
  - src/lib/abac/roleMapping.ts
  - src/app/area-cliente/page.tsx
  - src/hooks/useAuth.ts
  - src/components/ui/dashboard-usuario-widget.tsx
  - src/components/Header.tsx
  - src/app/area-cliente/dashboard-admin/PageDashboardAdmin.tsx
  - src/app/area-cliente/MenuLateralCliente.tsx
  - src/app/api/auth/session/route.ts
  - prisma/schema.prisma

---

## 3. Resqu√≠cios de RBAC/accessLevel
- **Evid√™ncias encontradas:**
  - Campo `accessLevel` ainda existe no schema do Prisma e √© utilizado em v√°rios pontos do c√≥digo (ex: MenuLateralCliente, PageDashboardAdmin, apiAuth.ts, session/route.ts).
  - Fun√ß√µes como `getRoleTypeLabel`, `hasRequiredRole` e mapeamentos em `roleMapping.ts` ainda consideram accessLevel.
  - O frontend e backend convertem accessLevel em "role" para exibi√ß√£o e controle de acesso.
  - Isso √© incompat√≠vel com ABAC/ASIC puro, que deveria usar apenas pol√≠ticas e atributos.

---

## 4. Compara√ß√£o com Modelo Oficial ASIC
- **Refer√™ncias:**
  - [ASIC Casbin Model](https://github.com/casbin/casbin)
  - [Casbin ABAC Docs](https://casbin.org/docs/en/abac)
  - [Prisma Adapter Casbin](https://github.com/node-casbin/prisma-adapter)
- **Diferen√ßas identificadas:**
  - **Nosso schema:**
    - User: id, email, name, accessLevel, etc.
    - UserRole: userId, roleId, roleType
    - AuthorizationPolicy: subject, object, action, effect
  - **Modelo ASIC puro:**
    - N√£o utiliza accessLevel
    - Pol√≠ticas s√£o baseadas em atributos (subject, object, action, environment)
    - Usu√°rios podem ter m√∫ltiplos atributos (n√£o apenas role)
    - N√£o h√° convers√£o de accessLevel para role
  - **Conclus√£o:** accessLevel √© um resqu√≠cio de RBAC e deve ser removido do schema, c√≥digo e seeds.

---

## 5. Seeds e Usu√°rios

### Diagn√≥stico dos Seeds
- **Arquivo seed encontrado:** `site-metodo/prisma/seeds/seed.ts`
- **Conte√∫do:**
  - Atualiza o campo `accessLevel` do usu√°rio `felipemartinii@gmail.com` para 5.
  - N√£o h√° seed para `felipemartiniii@gmail.com` (com 3 i), mas √© importante garantir que n√£o exista no banco.
  - O seed n√£o atribui roles, policies ou atributos ABAC/ASIC, apenas manipula accessLevel (RBAC legado).
- **Problema:**
  - O seed perpetua o uso de accessLevel, que deveria ser removido.
  - N√£o h√° seed para criar pol√≠ticas ABAC/ASIC para o admin.
  - N√£o h√° seed para garantir que o admin tenha todos os atributos/policies necess√°rios.

### Recomenda√ß√µes:
- Remover qualquer seed que manipule accessLevel.
- Criar seed que atribua policies ABAC/ASIC para o admin correto.
- Garantir que n√£o exista seed para emails errados.

---

---

## 6. Checklist de An√°lise Profunda
```markdown
- [x] Mapear todos os pontos do c√≥digo que usam accessLevel e sistema asic puro, onde estao as rela√ß√µes de permisoes e atributos todos inclusive isadmin e moderador, veja quais sao todos os atributos atualmente existems inclusive no banco de dados
- [x] Comparar schema atual com modelo ASIC oficial ver diferen√ßas exatas
- [x] Listar e analisar todos os seeds de usu√°rio
- [x] Diagnosticar seed do admin e aus√™ncia de seed para emails errados
- [ ] Verificar se h√° policies ABAC suficientes para admin e novos usu√°rios
- [ ] Mapear fluxo de autentica√ß√£o e atribui√ß√£o de atributos (roles/policies)
- [ ] Identificar e documentar todos os pontos de convers√£o accessLevel -> role
- [ ] Listar todos os lugares onde accessLevel √© usado para controle de acesso
- [ ] Propor plano de remo√ß√£o completa do accessLevel
- [ ] Validar se o admin tem todas as permiss√µes necess√°rias
- [ ] Validar se novos usu√°rios recebem atributos/policies corretos
- [ ] Verificar se n√£o h√° mais seeds ou usu√°rios inconsistentes
- [ ] Documentar refer√™ncias e links consultados
**Obrigat√≥rio:**
- [ ] Implementar seed autom√°tico para o usu√°rio `felipemartinii@gmail.com` como admin ABAC puro, com todas as permiss√µes necess√°rias, sempre que o projeto for criado do zero.
- [ ] O schema do banco de dados deve seguir exatamente o padr√£o ASIC/Casbin puro, sem campos RBAC (ex: accessLevel, roleType), apenas policies e atributos.
```

---

## 7. Refer√™ncias Utilizadas

- [Casbin ABAC Model Example](https://github.com/casbin/casbin/blob/master/examples/abac_model.conf)
- [Casbin GitHub](https://github.com/casbin/casbin)
- [Prisma Adapter Casbin](https://github.com/node-casbin/prisma-adapter)
- [ABAC vs RBAC](https://auth0.com/docs/secure/access-control/rbac/)
- [ASIC Model Overview](https://github.com/casbin/casbin/blob/master/docs/model.md)
- [Casbin Online Editor](https://casbin.org/editor/)

---

## 8. Observa√ß√µes Iniciais

- O sistema ainda depende de accessLevel para controle de acesso, o que √© incompat√≠vel com ABAC/ASIC puro.
- Seeds e policies precisam ser revisados para garantir que apenas o admin correto exista e que todos os controles sejam feitos via pol√≠ticas ABAC.
- O modelo recomendado pelo Casbin/ASIC para ABAC puro n√£o utiliza accessLevel, apenas policies `{subject, object, action}` e atributos.
- O modelo de tabela recomendado para persist√™ncia de policies √©:
  ```prisma
  model CasbinRule {
    id    Int     @id @default(autoincrement())
    ptype String
    v0    String?
    v1    String?
    v2    String?
    v3    String?
    v4    String?
    v5    String?

    @@map("casbin_rule")
  }
  ```
- Nosso schema mistura RBAC (accessLevel, roleType) e ABAC (AuthorizationPolicy), o que gera inconsist√™ncias.
- Pr√≥ximos passos: continuar checklist, detalhar cada ponto, propor plano de migra√ß√£o e corre√ß√£o.


---

## 9. An√°lise Comparativa Profunda do Banco de Dados

### Nosso Schema (atual)
- Modelo User possui `accessLevel` (Int) e `roleType` (enum UserRoleType), ambos herdados do RBAC.
- Modelo UserRole faz rela√ß√£o many-to-many entre User e Role, com campo `roleType` e enum.
- Modelo AuthorizationPolicy implementa policies ABAC, mas coexistem com RBAC.
- Seeds manipulam accessLevel, n√£o policies ABAC.

### Modelo ASIC/Casbin Puro (recomendado)
- N√£o existe `accessLevel`, `roleType` ou enum de roles.
- N√£o existe UserRoleType, nem UserRole.
- N√£o existe modelo Role separado.
- O controle √© feito apenas por policies `{subject, object, action}` e atributos.
- Persist√™ncia recomendada:
  ```prisma
  model CasbinRule {
    id    Int     @id @default(autoincrement())
    ptype String
    v0    String?
    v1    String?
    v2    String?
    v3    String?
    v4    String?
    v5    String?

    @@map("casbin_rule")
  }
  ```
- O usu√°rio admin deve ser criado via seed j√° com todas as policies necess√°rias (exemplo: `p, felipemartinii@gmail.com, /admin/abac, manage`).

### Conflito de nomenclatura e heran√ßa RBAC
- O campo `roleType` foi criado para tentar migrar do RBAC, mas conflita com o conceito de role do Casbin/ASIC, que √© apenas um atributo/policy.
- O campo `role` j√° existia no RBAC, mas no ABAC puro n√£o existe como entidade fixa, apenas como atributo/policy.
- Isso gerou conflitos na primeira instala√ß√£o e dificulta a ado√ß√£o do modelo puro.

### Problema central
- O banco de dados precisa ser migrado para o padr√£o ASIC/Casbin puro, eliminando todos os campos e entidades RBAC.
- O seed do admin deve ser ABAC puro, sem manipular accessLevel ou roleType, apenas policies.
- O sistema deve garantir que, ao criar o projeto do zero, o admin correto j√° exista com todas as permiss√µes ABAC necess√°rias.

---

## 10. Continua√ß√£o da An√°lise

---

## 11. Autentica√ß√£o: Auth.js v5, MFA, Account Linking e Provedores

- O sistema utiliza **Auth.js v5 beta puro**. N√£o pode haver resqu√≠cios de NextAuth v4.
- **Multifator (MFA)** implementado (TOTP, WebAuthn, etc) n√£o pode ser quebrado.
- **Account linking**: todos provedores de conta (Google, GitHub, etc) devem ser mantidos e n√£o podem ser removidos ou quebrados.
- O fluxo de login normal (senha/email) e login social (OAuth) deve funcionar normalmente, sem interrup√ß√µes.
- **Zod** √© utilizado para valida√ß√£o de dados e n√£o pode ser removido.
- Qualquer migra√ß√£o de schema ou refatora√ß√£o n√£o pode quebrar:
  - MFA
  - Account linking
  - Provedores sociais
  - Login normal
  - Valida√ß√µes Zod

### Checklist de Autentica√ß√£o
```markdown
- [ ] Garantir que n√£o h√° depend√™ncias de NextAuth v4
- [ ] Garantir que MFA, account linking e todos provedores funcionam ap√≥s migra√ß√£o
- [ ] Garantir que login social e normal funcionam sem interrup√ß√£o
- [ ] Garantir que Zod est√° presente e funcional
```

---

## 12. Problema de Redirecionamento: Localhost vs IP da Rede

- Ao logar via celular na rede interna, o sistema redireciona para `localhost:3000` ao inv√©s do IP da m√°quina (ex: `10.0.0.69:3000`).
- Isso impede o login em dispositivos que n√£o s√£o o pr√≥prio host.
- O comportamento padr√£o √© determinado pelo provedor OAuth (ex: Google), que exige que o **redirect URI** seja cadastrado no console do provedor.
- Normalmente, s√≥ √© poss√≠vel cadastrar um ou poucos redirect URIs por aplica√ß√£o no Google Console.
- **Problema:**
  - O sistema deveria ser flex√≠vel para aceitar o IP da rede ou o dom√≠nio acessado, n√£o apenas localhost.
  - O ideal seria que o redirect URI retornasse para o mesmo host/ip que originou a requisi√ß√£o.
- **Pontos de investiga√ß√£o:**
  - Como configurar redirect URIs din√¢micos para provedores OAuth?
  - √â poss√≠vel cadastrar m√∫ltiplos URIs no Google Console? H√° limites?
  - Existem estrat√©gias para ambientes de desenvolvimento (ex: usar ngrok, wildcard domains, etc)?
  - Como garantir que o fluxo de login social funcione tanto em localhost quanto em IP de rede?

---

## 13. Compara√ß√£o Detalhada: Nosso Schema vs ASIC/Casbin

---

## 14. An√°lise dos Atributos e Regras ABAC/ASIC Atuais vs Padr√£o ASIC

---

## üö® Destaque Cr√≠tico: Incompatibilidade de Enums/Campos Fixos/Strings com ABAC Puro

> **ATEN√á√ÉO:**
>
> O sistema ainda utiliza enums, campos fixos e checagem por string para admin/moderador (ex: `roleType`, `UserRoleType`, `accessLevel`, checagem de 'admin', 'moderador', etc.), o que √© **incompat√≠vel com ABAC puro**.
>
> **No padr√£o ASIC/ABAC puro:**
> - N√£o existem enums/campos fixos para roles.
> - N√£o existe checagem de permiss√£o por string ou enum no c√≥digo.
> - Tudo √© policy din√¢mica e atributos livres, definidos em tempo de execu√ß√£o.
>
> **Recomenda√ß√£o:**
> - Eliminar todos os enums/campos fixos de roles, accessLevel, UserRoleType, etc.
> - Centralizar permiss√µes em policies ABAC (CasbinRule).
> - Toda checagem de permiss√£o deve ser feita via enforcer ABAC, nunca por string ou enum.

---
---

## 15. Plano de Migra√ß√£o e Refatora√ß√£o para ABAC/ASIC Puro

### Etapas Recomendadas
1. **Remover todos os campos e enums RBAC do schema:**
  - accessLevel, roleType, UserRoleType, UserRole, Role, etc.
2. **Migrar policies para CasbinRule:**
  - Persistir todas as permiss√µes em CasbinRule, n√£o em AuthorizationPolicy.
3. **Refatorar c√≥digo para usar apenas enforcer ABAC:**
  - Eliminar checagens por string ('admin', 'moderador', etc.) e enums.
  - Toda autoriza√ß√£o deve ser feita via enforcer Casbin.
4. **Criar seed ABAC puro para admin:**
  - Exemplo: `p, felipemartinii@gmail.com, /admin/abac, manage`
5. **Revisar e adaptar testes, MFA, account linking, provedores sociais:**
  - Garantir que nada √© quebrado na autentica√ß√£o e fluxo de login.
6. **Documentar e treinar equipe para novo padr√£o ABAC puro.**

### Exemplo de Policies ABAC Puro
```csv
p, felipemartinii@gmail.com, /admin/abac, manage
p, grupo-moderadores, /admin, view
g, usuario@email.com, grupo-moderadores
```

---

## 16. Continua√ß√£o da An√°lise Aprofundada

### Mapeamento dos Principais Pontos de Checagem por Enum/Campo Fixo/String

- **Hooks e tipos:**
  - `useRegistrarUsuario.ts`: utiliza `accessLevel`.
  - `usuarioSchemas.ts`: valida `roleType`.
  - `next-auth.d.ts`: define `accessLevel`, `role`.
- **Componentes e l√≥gica de UI:**
  - `Header.tsx`: exibe links de admin/staff baseado em `role` string.
  - `Dashboard Admin`: widgets e rotas protegidas por checagem de `role` string.
- **Middleware e policies:**
  - `middleware.ts`, `hoc.tsx`: checagem de roles por string e array.
  - `prisma-adapter.ts`: busca e atribui roles via entidades e campos fixos.
- **Policies e modelos:**
  - `pure_abac_policies.csv`, `basic_policies.csv`: ainda h√° mistura de roles fixos e atributos din√¢micos.
  - Modelos h√≠bridos (RBAC+ABAC) presentes.
- **Enums e entidades:**
  - `UserRoleType`, `Role`, `UserRole` ainda existem no schema e c√≥digo comprar com github assic oficial puro se atualize e veja o que temos que mudar para manter o padrao puro.

### Recomenda√ß√µes para Refatora√ß√£o Incremental
1. **Priorizar refatora√ß√£o dos pontos de checagem de permiss√£o por string/enums:**
   - Substituir por chamadas ao enforcer ABAC.
2. **Remover gradualmente enums/campos fixos do schema e c√≥digo:**
   - Adaptar migrations e testes.
3. **Centralizar toda l√≥gica de autoriza√ß√£o em policies ABAC:**
   - Atualizar policies para usar apenas atributos din√¢micos.
4. **Documentar cada etapa e garantir retrocompatibilidade tempor√°ria at√© migra√ß√£o total.**

### Exemplos de Refatora√ß√£o
- Antes:
  ```ts
  if (user.role === 'admin') { /* ... */ }
  ```
- Depois:
  ```ts
  if (await enforcer.enforce(user.email, '/admin/abac', 'manage')) { /* ... */ }
  ```

---

- Mapear todos os pontos do c√≥digo que ainda fazem checagem por string ou enum para permiss√£o.
- Listar todos os lugares onde accessLevel, roleType, UserRoleType, Role, UserRole s√£o usados.
- Propor plano incremental de refatora√ß√£o para cada ponto identificado.
- Validar se todas as rotas e √°reas protegidas est√£o cobertas por policies ABAC.
- Garantir que o fluxo de autentica√ß√£o, MFA, account linking e provedores sociais n√£o seja afetado.
- Documentar exemplos de policies para todos os perfis do sistema (admin, moderador, editor, usu√°rio comum).

---

### Atributos e Regras Atuais no Projeto
- O sistema ainda utiliza atributos herdados do RBAC, como:
  - `accessLevel` (User)
  - `roleType` (User, UserRole, enum UserRoleType)
  - `isActive` (User, UserRole)
  - `Role` e `UserRole` (entidades e relacionamentos)
- Enum `UserRoleType` define: GUEST, USER, MODERATOR, ADMIN
- Diversos pontos do c√≥digo e banco usam strings como 'admin', 'moderador', 'editor', 'viewer' para checagem de permiss√µes.
- Policies ABAC s√£o implementadas em `AuthorizationPolicy`, mas coexistem com RBAC.
- N√£o h√° atributo `isAdmin` expl√≠cito, mas a l√≥gica de admin/moderador √© feita via roleType, accessLevel ou role string.

### Padr√£o ASIC/ABAC Recomendado
- N√£o existe `accessLevel`, `roleType`, `UserRoleType`, nem entidades Role/UserRole.
- N√£o h√° enum fixo de roles; qualquer atributo pode ser usado como subject em policies.
- Atributos s√£o livres e definidos por policies, ex:
  - `p, felipemartinii@gmail.com, /admin/abac, manage`
  - `p, grupo-moderadores, /admin, view`
- N√£o h√° checagem de 'admin', 'moderador', etc. por string fixa no c√≥digo; tudo √© policy.
- Atributos podem ser adicionados como claims extras no usu√°rio, mas n√£o como enum ou campo fixo.

### Diferen√ßas e Recomenda√ß√µes
- O sistema atual mistura checagem de role por string, enums e policies, o que gera inconsist√™ncia e dificulta manuten√ß√£o.
- Recomenda-se:
  - Remover todos os enums e campos fixos de role/accessLevel/moderador/admin.
  - Centralizar todas as permiss√µes em policies ABAC (CasbinRule).
  - Se necess√°rio, criar grupos (ex: grupo-admins) via policies, n√£o via enum/campo fixo.
  - Checagens de permiss√£o devem ser sempre via Casbin (enforcer), nunca por string ou enum no c√≥digo.
- Exemplo de policy ABAC puro:
  - `p, felipemartinii@gmail.com, /admin/abac, manage`
  - `p, grupo-moderadores, /admin, view`
  - `g, usuario@email.com, grupo-moderadores`

### Resumo
- O modelo ASIC puro √© mais flex√≠vel, seguro e f√°cil de manter.
- Atributos como isAdmin/moderador devem ser eliminados do schema/c√≥digo e substitu√≠dos por policies din√¢micas.
- Toda l√≥gica de permiss√£o deve ser centralizada no enforcer ABAC.

---

### Nosso Schema (resumo)
- User: id, name, email, accessLevel, roleType, MFA, relacionamentos Auth.js, etc.
- UserRole: userId, roleId, roleType, etc.
- Role: id, name, description, attributes
- AuthorizationPolicy: subject, object, action, effect, conditions
- Diversos modelos auxiliares para MFA, notifica√ß√µes, logs, etc.

### ASIC/Casbin Puro
- User: id, name, email, MFA, relacionamentos m√≠nimos
- CasbinRule: id, ptype, v0-v5 (policies)
- N√£o existe accessLevel, roleType, UserRole, Role separado
- Policies s√£o persistidas em CasbinRule, n√£o em AuthorizationPolicy
- Todos os controles de acesso s√£o feitos via policies `{subject, object, action}`

### Diferen√ßas Cr√≠ticas
- Nosso schema mistura RBAC e ABAC, ASIC puro √© s√≥ ABAC
- Temos entidades e enums extras (roleType, accessLevel, UserRole)
- Policies n√£o est√£o centralizadas em CasbinRule
- MFA, notifica√ß√µes e logs podem ser mantidos, mas n√£o podem interferir no controle de acesso

### Banco de Dados
- **Obrigat√≥rio:** Todo o banco de dados e tabelas do ASIC devem estar em **SQLite** (compat√≠vel com Casbin/Prisma)
- O modelo CasbinRule deve ser implementado exatamente como recomendado

---

- Pr√≥ximos passos: detalhar fluxo de autentica√ß√£o, mapear convers√µes accessLevel‚Üírole, listar todos os usos de accessLevel, propor plano de migra√ß√£o e corre√ß√£o.

---

*Este arquivo ser√° atualizado continuamente durante a an√°lise.*
